---
phase: 02-component-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAnimationFrame.ts
  - src/hooks/usePerlinNoise.ts
  - src/hooks/useAnimationFrame.test.ts
  - src/hooks/usePerlinNoise.test.ts
autonomous: true

must_haves:
  truths:
    - "useAnimationFrame hook manages RAF lifecycle correctly"
    - "useAnimationFrame hook supports frame rate throttling"
    - "usePerlinNoise hook returns stable Perlin instance across re-renders"
    - "Both hooks clean up properly on unmount"
  artifacts:
    - path: "src/hooks/useAnimationFrame.ts"
      provides: "Reusable animation frame hook with throttling"
      exports: ["useAnimationFrame"]
    - path: "src/hooks/usePerlinNoise.ts"
      provides: "Stable Perlin noise instance hook"
      exports: ["usePerlinNoise"]
    - path: "src/hooks/useAnimationFrame.test.ts"
      provides: "Unit tests for animation frame hook"
      min_lines: 30
    - path: "src/hooks/usePerlinNoise.test.ts"
      provides: "Unit tests for noise hook"
      min_lines: 25
  key_links:
    - from: "src/hooks/useAnimationFrame.ts"
      to: "requestAnimationFrame"
      via: "useEffect with cleanup"
      pattern: "cancelAnimationFrame"
    - from: "src/hooks/usePerlinNoise.ts"
      to: "src/components/Perlin.tsx"
      via: "import"
      pattern: "import.*Perlin"
---

<objective>
Extract animation and noise logic into reusable custom hooks as foundation for Wave class-to-functional migration.

Purpose: Create tested, reusable hooks that encapsulate the RAF lifecycle and Perlin noise instance management, enabling clean functional component migration.
Output: Two custom hooks (useAnimationFrame, usePerlinNoise) with comprehensive unit tests.
</objective>

<execution_context>
@/Users/romatroskin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/romatroskin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-component-architecture/02-CONTEXT.md
@.planning/phases/02-component-architecture/02-RESEARCH.md
@src/components/Waves.tsx
@src/components/Perlin.tsx
@src/components/Perlin.test.tsx
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAnimationFrame hook</name>
  <files>src/hooks/useAnimationFrame.ts</files>
  <action>
Create custom hook that manages requestAnimationFrame lifecycle with these features:

1. **API Design:**
   ```typescript
   function useAnimationFrame(
     callback: (elapsed: number) => void,
     options?: { fps?: number; paused?: boolean }
   ): void
   ```

2. **Implementation requirements:**
   - Use useRef for frameId, previousTime, and elapsed (NOT useState - avoid re-renders)
   - Support configurable frame rate throttling (default 30fps to match current Wave)
   - Support paused state that maintains elapsed time but skips callback
   - Clean up with cancelAnimationFrame on unmount
   - Use useCallback for the animate function with correct dependencies
   - Handle initial timestamp case (previousTime undefined on first frame)

3. **Frame throttling logic (from current Waves.tsx lines 154-166):**
   ```typescript
   const frameInterval = 1000 / fps;
   if (elapsed >= frameInterval) {
     totalElapsed.current += elapsed;
     previousTime.current = timestamp;
     callback(totalElapsed.current);
   }
   ```

4. **TypeScript:** Full type annotations, no any types
  </action>
  <verify>
File exists at src/hooks/useAnimationFrame.ts with:
- Exported useAnimationFrame function
- useRef for frameId, previousTime refs
- useEffect with cleanup returning cancelAnimationFrame
- Frame rate throttling logic
  </verify>
  <done>useAnimationFrame hook created with RAF lifecycle management and frame throttling</done>
</task>

<task type="auto">
  <name>Task 2: Create usePerlinNoise hook</name>
  <files>src/hooks/usePerlinNoise.ts</files>
  <action>
Create custom hook that provides a stable Perlin noise instance:

1. **API Design:**
   ```typescript
   function usePerlinNoise(seed?: number): Perlin
   ```

2. **Implementation requirements:**
   - Generate stable seed with useMemo if not provided (Math.random() captured once)
   - Use useRef to hold Perlin instance (lazy initialization pattern)
   - Return same instance across re-renders (referential stability)
   - Import Perlin class from ../components/Perlin

3. **Lazy initialization pattern:**
   ```typescript
   const perlinRef = useRef<Perlin>();
   if (!perlinRef.current) {
     perlinRef.current = new Perlin(stableSeed);
   }
   return perlinRef.current;
   ```

4. **TypeScript:** Import and use Perlin type properly
  </action>
  <verify>
File exists at src/hooks/usePerlinNoise.ts with:
- Exported usePerlinNoise function
- Import of Perlin from components
- useRef for instance storage
- useMemo for stable seed
  </verify>
  <done>usePerlinNoise hook created with stable instance management</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for custom hooks</name>
  <files>src/hooks/useAnimationFrame.test.ts, src/hooks/usePerlinNoise.test.ts</files>
  <action>
Create unit tests for both hooks using renderHook from @testing-library/react:

**useAnimationFrame.test.ts:**
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook } from '@testing-library/react';
import { useAnimationFrame } from './useAnimationFrame';
```

1. Test callback is called with elapsed time
2. Test frame throttling respects fps setting
3. Test paused state skips callback execution
4. Test cleanup cancels animation frame on unmount
5. Use vi.useFakeTimers() and vi.advanceTimersByTime() for timing tests

**usePerlinNoise.test.ts:**
```typescript
import { describe, it, expect } from 'vitest';
import { renderHook } from '@testing-library/react';
import { usePerlinNoise } from './usePerlinNoise';
```

1. Test returns same instance across re-renders (reference equality)
2. Test different seeds produce different noise values
3. Test stable seed generation when seed not provided
4. Test returned Perlin instance works (perlin2 produces valid output)

**Test patterns from existing Perlin.test.tsx:**
- Use describe/it blocks
- Use explicit assertions (expect().toBe, expect().not.toBe)
- Test edge cases (seed = 0, missing seed)
  </action>
  <verify>
Run: `npm test -- --run`

Both test files pass:
- useAnimationFrame.test.ts: callback called, throttling works, cleanup works
- usePerlinNoise.test.ts: instance stability, seed handling
  </verify>
  <done>Unit tests pass for both hooks covering lifecycle, behavior, and edge cases</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Hooks exist and export correctly:**
   ```bash
   grep -l "export.*useAnimationFrame" src/hooks/useAnimationFrame.ts
   grep -l "export.*usePerlinNoise" src/hooks/usePerlinNoise.ts
   ```

2. **Tests pass:**
   ```bash
   npm test -- --run
   ```
   All tests should pass including the new hook tests.

3. **No TypeScript errors:**
   ```bash
   npx tsc --noEmit
   ```

4. **Coverage includes hooks:**
   ```bash
   npm test -- --coverage --run
   ```
   Both hook files should appear in coverage report.
</verification>

<success_criteria>
- Two new files in src/hooks/ directory (useAnimationFrame.ts, usePerlinNoise.ts)
- Both hooks have corresponding test files with passing tests
- useAnimationFrame supports throttled 30fps animation
- usePerlinNoise returns stable Perlin instance
- No TypeScript errors
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-component-architecture/02-01-SUMMARY.md`
</output>
