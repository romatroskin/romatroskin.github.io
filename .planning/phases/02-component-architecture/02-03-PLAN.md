---
phase: 02-component-architecture
plan: 03
type: execute
wave: 1
depends_on: ["02-02"]
files_modified:
  - src/components/Waves.tsx
  - src/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Wave path extends to full container width at all viewport sizes (no cutoff)"
    - "Scroll position changes update wave height, amplitude, and speed in real-time"
    - "Container measurement captures correct width before first render"
  artifacts:
    - path: "src/components/Waves.tsx"
      provides: "Fixed wave path calculation and Interpolation value reading"
      contains: "ResizeObserver"
    - path: "src/App.tsx"
      provides: "Fixed scroll binding timing with parallax container"
      contains: "scrollY"
  key_links:
    - from: "src/components/Waves.tsx"
      to: "ResizeObserver"
      via: "container measurement"
      pattern: "ResizeObserver"
    - from: "src/App.tsx"
      to: "useScroll"
      via: "window scroll tracking"
      pattern: "useScroll\\(\\)"
---

<objective>
Fix scroll responsiveness and wave cutoff issues identified during Phase 2 verification.

Purpose: Close gaps preventing visual parity - waves must respond to scroll position and render at full container width across all viewport sizes.
Output: Wave component with fixed container measurement and proper scroll-driven animation.
</objective>

<execution_context>
@/Users/romatroskin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/romatroskin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-component-architecture/02-VERIFICATION.md
@.planning/phases/02-component-architecture/02-02-SUMMARY.md
@.planning/phases/02-component-architecture/02-RESEARCH.md
@src/components/Waves.tsx
@src/App.tsx
@src/hooks/useAnimationFrame.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix scroll binding in App.tsx by removing container option</name>
  <files>src/App.tsx</files>
  <action>
The useScroll hook uses `container: parallaxRef?.current?.container` which binds to the Parallax internal scroll container. However, the waves are rendered OUTSIDE the Parallax component - they're siblings, not children (lines 54-111 vs line 112).

**Root cause:** Architectural mismatch. The waves are positioned absolutely in a separate div that fills the viewport. They should respond to WINDOW scroll, not the internal Parallax scroll container. The current setup binds to a container that doesn't contain the waves.

**Fix:** Remove the `container` option from useScroll() so it tracks window scroll.

Change:
```typescript
const { scrollY } = useScroll({
    container: parallaxRef?.current?.container,
});
```

To:
```typescript
const { scrollY } = useScroll();
```

This makes scrollY track window scroll position. Since the waves are positioned absolutely over the entire viewport (not inside Parallax), window scroll is the correct source.

**Why this works:** The waves are rendered in a div with `position: absolute` covering the full viewport. When the user scrolls the window, the waves should respond. The Parallax component has its own internal scrolling mechanism that doesn't affect elements outside it.

**Verification:** Scroll the page and verify scrollY.get() returns non-zero values.
  </action>
  <verify>
1. Run `npm run dev`
2. Open browser console
3. Add temporary log: `console.log('scrollY:', scrollY.get())` after scroll
4. Scroll the page - scrollY value should change from 0
  </verify>
  <done>scrollY tracks window scroll correctly, updating wave properties as user scrolls</done>
</task>

<task type="auto">
  <name>Task 2: Fix wave container measurement with ResizeObserver</name>
  <files>src/components/Waves.tsx</files>
  <action>
The current resize handler uses window.addEventListener('resize') which has two issues:
1. Container might not be measured correctly on initial render (offsetWidth could be 0)
2. Window resize doesn't catch container-specific size changes

**Fix approach:** Replace window resize listener with ResizeObserver on the container element.

1. Use ResizeObserver to observe the container element:
   ```typescript
   useEffect(() => {
     if (!containerRef.current) return;

     const observer = new ResizeObserver((entries) => {
       const entry = entries[0];
       if (entry) {
         containerSize.current = {
           width: entry.contentRect.width,
           height: entry.contentRect.height,
         };
       }
     });

     observer.observe(containerRef.current);

     return () => observer.disconnect();
   }, []);
   ```

2. Add extra width buffer to prevent cutoff at edge:
   - The current path builds to exactly `containerWidth`
   - Add 5-10px buffer or use `Math.ceil` to ensure full coverage
   - In buildPath, change:
     ```typescript
     svg += ` L ${containerWidth + 1} ${containerHeight}`;
     svg += ` L -1 ${containerHeight} Z`;
     ```

3. Handle initial 0-width case:
   - If containerWidth is 0, skip path calculation or use a reasonable default
   - Add guard: `if (containerWidth <= 0) return [];` in calculateWavePoints

**Remove:** Delete the old window.addEventListener('resize') code.
  </action>
  <verify>
1. Run `npm run dev`
2. Resize browser window to various widths (320px, 768px, 1024px, 1440px, 1920px)
3. Wave should extend to full width with no visible cutoff on right edge
  </verify>
  <done>Wave renders at full container width at all viewport sizes without cutoff</done>
</task>

<task type="auto">
  <name>Task 3: Verify Interpolation.get() timing in animation loop</name>
  <files>src/components/Waves.tsx</files>
  <action>
Double-check that Interpolation values are being read correctly in the animation loop.

**Current implementation review:**
```typescript
// Line 65-66: animatedPropsRef stores props
const animatedPropsRef = useRef({ speed, height, amplitude, points });
animatedPropsRef.current = { speed, height, amplitude, points };

// Line 109-112: getAnimatedValue called on ref values
const speedValue = getAnimatedValue(speedProp);
const heightValue = getAnimatedValue(heightProp);
const amplitudeValue = getAnimatedValue(amplitudeProp);
```

**Verification steps:**
1. Add temporary debug logging to confirm values change:
   ```typescript
   // In calculateWavePoints, after getting animated values:
   if (process.env.NODE_ENV === 'development' && Math.random() < 0.01) {
     console.log('Animated values:', { speedValue, heightValue, amplitudeValue });
   }
   ```

2. Verify that animatedPropsRef.current is updated on every render (line 66 is outside any hook/callback)

3. Verify getAnimatedValue properly handles both number and Interpolation:
   - Raw number: returns as-is
   - Interpolation: calls .get() to get current interpolated value

**If values still don't update:** The issue is in App.tsx scroll binding (Task 1), not here.

**After verification:** Remove debug logging before commit.
  </action>
  <verify>
1. Run `npm run dev`
2. Scroll page
3. Observe wave behavior - height/amplitude should change visually
4. If debug logs were added, verify values change in console
5. Remove any debug logging
  </verify>
  <done>Interpolation values correctly read and applied during scroll-driven animation</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Scroll responsiveness:**
   ```bash
   # Start dev server
   npm run dev
   # In browser: scroll the page, waves should visually change height/amplitude/speed
   ```

2. **Full-width rendering:**
   - Resize browser to various widths
   - Wave should fill entire container with no visible right-edge cutoff
   - Test at: 320px, 768px, 1024px, 1440px, 1920px

3. **All tests pass:**
   ```bash
   npm test -- --run
   ```

4. **TypeScript compiles:**
   ```bash
   npx tsc --noEmit
   ```
</verification>

<success_criteria>
- Waves respond to scroll position changes (height, amplitude, speed vary as you scroll)
- Wave path extends to full container width at all viewport sizes
- No visible cutoff on right edge of waves
- Animation continues smoothly during scroll
- All existing tests pass
- No new console errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-component-architecture/02-03-SUMMARY.md`
</output>
