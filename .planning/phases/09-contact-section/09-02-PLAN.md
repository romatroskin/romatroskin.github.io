---
phase: 09-contact-section
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/components/sections/ContactSection/ContactSection.tsx
  - src/components/ui/Header/Header.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Visitor can type in Name, Email, and Message fields"
    - "Validation errors appear when leaving empty required fields"
    - "Email validation shows error for invalid email format"
    - "Form displays 'Sending...' state during submission"
    - "Form is replaced with thank-you message after successful submission"
    - "GitHub and LinkedIn icons are visible below the form"
    - "Contact appears in navigation and scrolls to section when clicked"
  artifacts:
    - path: "src/components/sections/ContactSection/ContactSection.tsx"
      provides: "Complete contact form with Formspree integration"
      exports: ["default"]
      min_lines: 100
    - path: "src/App.tsx"
      provides: "Lazy-loaded ContactSection on page 4"
      contains: "ContactSection"
  key_links:
    - from: "src/components/sections/ContactSection/ContactSection.tsx"
      to: "@formspree/react"
      via: "useForm hook"
      pattern: "useForm"
    - from: "src/App.tsx"
      to: "ContactSection"
      via: "React.lazy import"
      pattern: "lazy.*ContactSection"
    - from: "src/components/ui/Header/Header.tsx"
      to: "Contact navigation"
      via: "navItems array"
      pattern: 'label.*Contact.*page.*3'
---

<objective>
Implement complete contact form with Formspree integration and add section to navigation.

Purpose: Build the full contact section with form validation, submission handling, social links, and integrate it into the site's navigation and parallax layout.

Output: Fully functional contact section with accessible form, social links, and navigation integration.
</objective>

<execution_context>
@/Users/romatroskin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/romatroskin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-contact-section/09-CONTEXT.md
@.planning/phases/09-contact-section/09-RESEARCH.md
@.planning/phases/09-contact-section/09-01-SUMMARY.md
@src/App.tsx
@src/components/ui/Header/Header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement complete contact form with Formspree</name>
  <files>src/components/sections/ContactSection/ContactSection.tsx</files>
  <action>
    Replace the skeleton ContactSection with full form implementation:

    ```typescript
    import { useState, useCallback } from 'react';
    import { useForm, ValidationError } from '@formspree/react';
    import { SocialIcon } from 'react-social-icons';
    import styles from './ContactSection.module.css';

    interface FormData {
      name: string;
      email: string;
      message: string;
    }

    interface FormErrors {
      name: string;
      email: string;
      message: string;
    }

    interface TouchedFields {
      name: boolean;
      email: boolean;
      message: boolean;
    }

    // Placeholder - replace with actual Formspree form ID
    const FORMSPREE_FORM_ID = 'YOUR_FORM_ID';

    export default function ContactSection() {
      const [state, handleSubmit] = useForm(FORMSPREE_FORM_ID);
      const [formData, setFormData] = useState<FormData>({ name: '', email: '', message: '' });
      const [errors, setErrors] = useState<FormErrors>({ name: '', email: '', message: '' });
      const [touched, setTouched] = useState<TouchedFields>({ name: false, email: false, message: false });

      const validateField = useCallback((field: keyof FormData, value: string): string => {
        switch (field) {
          case 'name':
            if (!value.trim()) return 'Name is required';
            if (value.trim().length < 2) return 'Name must be at least 2 characters';
            return '';
          case 'email':
            if (!value.trim()) return 'Email is required';
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
              return 'Please enter a valid email address';
            }
            return '';
          case 'message':
            if (!value.trim()) return 'Message is required';
            if (value.trim().length < 10) return 'Message must be at least 10 characters';
            return '';
          default:
            return '';
        }
      }, []);

      const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));

        // If field was touched, validate on change for immediate feedback
        if (touched[name as keyof TouchedFields]) {
          setErrors(prev => ({ ...prev, [name]: validateField(name as keyof FormData, value) }));
        }
      }, [touched, validateField]);

      const handleBlur = useCallback((field: keyof FormData) => {
        setTouched(prev => ({ ...prev, [field]: true }));
        setErrors(prev => ({ ...prev, [field]: validateField(field, formData[field]) }));
      }, [formData, validateField]);

      const isFormValid = useCallback(() => {
        const nameError = validateField('name', formData.name);
        const emailError = validateField('email', formData.email);
        const messageError = validateField('message', formData.message);
        return !nameError && !emailError && !messageError;
      }, [formData, validateField]);

      const onSubmit = useCallback((e: React.FormEvent<HTMLFormElement>) => {
        // Touch all fields to show any errors
        setTouched({ name: true, email: true, message: true });

        // Validate all fields
        const newErrors = {
          name: validateField('name', formData.name),
          email: validateField('email', formData.email),
          message: validateField('message', formData.message),
        };
        setErrors(newErrors);

        // Only submit if valid
        if (isFormValid()) {
          handleSubmit(e);
        } else {
          e.preventDefault();
        }
      }, [formData, validateField, isFormValid, handleSubmit]);

      // Show success message after form submission
      if (state.succeeded) {
        return (
          <section id="contact-section" aria-labelledby="contact-heading">
            <div className={`${styles.contactCard} content-card`}>
              <div className={styles.successMessage} role="status" aria-live="polite">
                <h3>Thank you for reaching out!</h3>
                <p>We have received your message and will get back to you soon.</p>
              </div>
              <SocialLinks />
            </div>
          </section>
        );
      }

      return (
        <section id="contact-section" aria-labelledby="contact-heading">
          <div className={`${styles.contactCard} content-card`}>
            <h2 id="contact-heading" className="section-title">Get In Touch</h2>

            <form onSubmit={onSubmit} className={styles.form} noValidate>
              {/* Name field */}
              <div className={styles.formField}>
                <label htmlFor="contact-name" className={styles.formLabel}>
                  Name <span aria-label="required">*</span>
                </label>
                <input
                  id="contact-name"
                  name="name"
                  type="text"
                  value={formData.name}
                  onChange={handleChange}
                  onBlur={() => handleBlur('name')}
                  aria-invalid={touched.name && !!errors.name}
                  aria-describedby={errors.name ? 'name-error' : undefined}
                  aria-required="true"
                  className={styles.formInput}
                  autoComplete="name"
                />
                {touched.name && errors.name && (
                  <span id="name-error" className={styles.errorMessage} role="alert">
                    {errors.name}
                  </span>
                )}
                <ValidationError prefix="Name" field="name" errors={state.errors} />
              </div>

              {/* Email field */}
              <div className={styles.formField}>
                <label htmlFor="contact-email" className={styles.formLabel}>
                  Email <span aria-label="required">*</span>
                </label>
                <input
                  id="contact-email"
                  name="email"
                  type="email"
                  value={formData.email}
                  onChange={handleChange}
                  onBlur={() => handleBlur('email')}
                  aria-invalid={touched.email && !!errors.email}
                  aria-describedby={errors.email ? 'email-error' : undefined}
                  aria-required="true"
                  className={styles.formInput}
                  autoComplete="email"
                />
                {touched.email && errors.email && (
                  <span id="email-error" className={styles.errorMessage} role="alert">
                    {errors.email}
                  </span>
                )}
                <ValidationError prefix="Email" field="email" errors={state.errors} />
              </div>

              {/* Message field */}
              <div className={styles.formField}>
                <label htmlFor="contact-message" className={styles.formLabel}>
                  Message <span aria-label="required">*</span>
                </label>
                <textarea
                  id="contact-message"
                  name="message"
                  value={formData.message}
                  onChange={handleChange}
                  onBlur={() => handleBlur('message')}
                  aria-invalid={touched.message && !!errors.message}
                  aria-describedby={errors.message ? 'message-error' : undefined}
                  aria-required="true"
                  className={styles.formTextarea}
                  rows={5}
                />
                {touched.message && errors.message && (
                  <span id="message-error" className={styles.errorMessage} role="alert">
                    {errors.message}
                  </span>
                )}
                <ValidationError prefix="Message" field="message" errors={state.errors} />
              </div>

              {/* Submit button */}
              <button
                type="submit"
                disabled={state.submitting}
                aria-busy={state.submitting}
                className={`cta-primary ${styles.submitButton}`}
              >
                {state.submitting ? 'Sending...' : 'Send Message'}
              </button>
            </form>

            <SocialLinks />
          </div>
        </section>
      );
    }

    // Social links component
    function SocialLinks() {
      return (
        <div className={styles.socialLinks} aria-label="Social media profiles">
          <SocialIcon
            url="https://github.com/puffpuffdev"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="GitHub profile (opens in new tab)"
            style={{ height: 44, width: 44 }}
            className={styles.socialLink}
          />
          <SocialIcon
            url="https://linkedin.com/company/puffpuffdev"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="LinkedIn profile (opens in new tab)"
            style={{ height: 44, width: 44 }}
            className={styles.socialLink}
          />
        </div>
      );
    }
    ```

    **Key implementation decisions:**
    - Uses `useForm` from @formspree/react for submission handling
    - Controlled components with useState for form data
    - Blur-based validation per CONTEXT.md
    - ARIA attributes for accessibility (aria-invalid, aria-describedby, role="alert")
    - Form replacement on success (not inline message)
    - SocialIcon from react-social-icons for GitHub/LinkedIn
    - 44x44px touch targets for WCAG compliance
    - Placeholder Formspree ID (documented for user to replace)

    **Note:** The `FORMSPREE_FORM_ID` constant is a placeholder. User must create a Formspree form and replace 'YOUR_FORM_ID' with their actual form ID.
  </action>
  <verify>
    - Run `npx tsc --noEmit` - no TypeScript errors
    - Verify component renders in browser (dev server)
    - Check form fields are present and styled
  </verify>
  <done>
    ContactSection renders complete form with Name, Email, Message fields.
    Validation shows errors on blur for empty/invalid fields.
    Submit button shows "Sending..." during submission.
    Social links (GitHub, LinkedIn) appear below form.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Header navigation to include Contact</name>
  <files>src/components/ui/Header/Header.tsx</files>
  <action>
    Update the navItems array in Header.tsx to change Contact from external mailto link to internal page navigation:

    Change the Contact nav item from:
    ```typescript
    { label: "Contact", page: -1, isExternal: true, href: "mailto:contact@puffpuff.dev" },
    ```

    To:
    ```typescript
    { label: "Contact", page: 3 },
    ```

    The complete navItems array should be:
    ```typescript
    export const navItems: NavItem[] = [
        { label: "Home", page: 0 },
        { label: "Services", page: 1 },
        { label: "About", page: 2 },
        { label: "Contact", page: 3 },
    ];
    ```

    This removes the external mailto link behavior and makes Contact scroll to page 3 (the new contact section) using the existing navigation system.
  </action>
  <verify>
    - Run `npx tsc --noEmit` - no TypeScript errors
    - Contact appears in header navigation
    - Clicking Contact scrolls to correct section
  </verify>
  <done>
    Contact nav item changed from mailto link to page: 3.
    Navigation system recognizes Contact as internal section.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ContactSection to App.tsx parallax layout</name>
  <files>src/App.tsx</files>
  <action>
    Integrate ContactSection into App.tsx as the 4th parallax page:

    1. Add lazy import at top with other section imports:
    ```typescript
    const ContactSection = lazy(() => import("@/components/sections/ContactSection/ContactSection"));
    ```

    2. Update TOTAL_PAGES constant:
    ```typescript
    const TOTAL_PAGES = 4;
    ```

    3. Add new ParallaxLayer for Page 4 after the About section (around line 358):
    ```tsx
    {/* Page 4: Contact */}
    <ParallaxLayer
        offset={3}
        speed={0.5 * animationParams.parallaxSpeedMultiplier}
        style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
        }}
    >
        <Suspense fallback={<SectionLoader />}>
            <ContactSection />
        </Suspense>
    </ParallaxLayer>
    ```

    The complete structure should be:
    - Page 0: Hero (offset 0)
    - Page 1: Services (offset 1)
    - Page 2: About (offset 2)
    - Page 3: Contact (offset 3) - NEW

    Note: Speed increases slightly for each layer (0.2, 0.3, 0.4, 0.5) for parallax depth effect.
  </action>
  <verify>
    - Run `npx tsc --noEmit` - no TypeScript errors
    - Run `npm run build` - builds without errors
    - Run dev server and scroll through all 4 pages
    - Contact section visible on page 4
    - Navigation scrolls to Contact correctly
  </verify>
  <done>
    ContactSection lazy-loaded in App.tsx.
    TOTAL_PAGES updated to 4.
    Contact section appears as page 4 in parallax.
    Navigation scrolls correctly to all sections.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - builds without errors
2. Run `npm run dev` and verify in browser:
   - Form renders with 3 fields (Name, Email, Message)
   - Blur validation shows errors for empty/invalid fields
   - Social icons (GitHub, LinkedIn) visible below form
   - Navigation includes Contact and scrolls correctly
   - Dark/light theme works on contact section
3. Keyboard navigation: Tab through form fields, Enter submits
</verification>

<success_criteria>
- Contact form renders with accessible labels and validation
- Blur validation shows descriptive error messages
- Submit button shows "Sending..." during submission
- Success message replaces form after submission
- GitHub and LinkedIn icons visible with proper accessibility
- Navigation includes Contact item that scrolls to section
- Build succeeds: `npm run build`
</success_criteria>

<output>
After completion, create `.planning/phases/09-contact-section/09-02-SUMMARY.md`
</output>
