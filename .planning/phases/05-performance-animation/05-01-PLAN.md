---
phase: 05-performance-animation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/performance/vitals.ts
  - src/performance/loafMonitor.ts
  - src/hooks/usePrefersReducedMotion.ts
  - src/components/Perlin.tsx
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Web Vitals (LCP, INP, CLS) are logged to console in development"
    - "Long Animation Frames with blocking >100ms are detected and logged"
    - "usePrefersReducedMotion hook returns correct preference from OS"
    - "Hook responds to real-time changes in system motion preference"
    - "Perlin noise calculations are memoized with cache to reduce CPU load"
  artifacts:
    - path: "src/performance/vitals.ts"
      provides: "Web Vitals monitoring setup"
      exports: ["initWebVitals"]
    - path: "src/performance/loafMonitor.ts"
      provides: "Long Animation Frames API monitoring"
      exports: ["monitorLongAnimationFrames"]
    - path: "src/hooks/usePrefersReducedMotion.ts"
      provides: "React hook for motion preference detection"
      exports: ["usePrefersReducedMotion"]
    - path: "src/components/Perlin.tsx"
      provides: "Memoized Perlin noise implementation"
      contains: "noiseCache"
  key_links:
    - from: "src/main.tsx"
      to: "src/performance/vitals.ts"
      via: "initWebVitals() call"
      pattern: "initWebVitals\\(\\)"
    - from: "src/main.tsx"
      to: "src/performance/loafMonitor.ts"
      via: "monitorLongAnimationFrames() call"
      pattern: "monitorLongAnimationFrames\\(\\)"
---

<objective>
Create performance measurement infrastructure with Web Vitals monitoring, reduced motion detection, and Perlin noise memoization.

Purpose: Establish baseline metrics before optimization - "measure first, optimize based on data." Also implement critical memoization for Perlin noise calculations.
Output: Web Vitals logging, Long Animation Frames detection, usePrefersReducedMotion hook, and memoized Perlin noise ready for integration.
</objective>

<execution_context>
@/Users/romatroskin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/romatroskin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-animation/05-RESEARCH.md

# Relevant source files
@src/main.tsx
@src/components/Perlin.tsx
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install web-vitals and create monitoring infrastructure</name>
  <files>
    - package.json
    - src/performance/vitals.ts
    - src/performance/loafMonitor.ts
  </files>
  <action>
    1. Install web-vitals: `npm install web-vitals`

    2. Create src/performance/vitals.ts:
       - Import onLCP, onINP, onCLS, onFCP, onTTFB from 'web-vitals'
       - Create initWebVitals() function that:
         - In development (import.meta.env.DEV): logs metrics to console with formatted output
         - In production: uses navigator.sendBeacon if available (can be no-op for now, no analytics endpoint)
       - Export initWebVitals

    3. Create src/performance/loafMonitor.ts:
       - Check if Long Animation Frames API is supported via PerformanceObserver.supportedEntryTypes
       - Create PerformanceObserver for 'long-animation-frame' entries
       - Log frames with blockingDuration > 100ms that have user interactions (firstUIEventTimestamp > 0)
       - Include script attribution (invoker, sourceURL, sourceFunctionName) in logs
       - Export monitorLongAnimationFrames function

    Follow patterns exactly from 05-RESEARCH.md code examples.
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - Files exist: src/performance/vitals.ts, src/performance/loafMonitor.ts
    - Both files export their main functions
  </verify>
  <done>
    - web-vitals package installed
    - vitals.ts logs LCP, INP, CLS, FCP, TTFB in dev mode
    - loafMonitor.ts detects and logs long animation frames with interaction
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usePrefersReducedMotion hook and add Perlin noise memoization</name>
  <files>
    - src/hooks/usePrefersReducedMotion.ts
    - src/components/Perlin.tsx
  </files>
  <action>
    1. Create src/hooks/usePrefersReducedMotion.ts following the pattern from 05-RESEARCH.md:

       Query '(prefers-reduced-motion: no-preference)' - note the inverted logic
       Use useState with SSR-safe initial value (default true until hydration)
       In useEffect:
         - Get matchMedia result
         - Set initial value based on !matches (reduced motion = true when user prefers reduced)
         - Add 'change' event listener for real-time updates
         - Clean up listener on unmount
       Return boolean: true = user prefers reduced motion, false = no preference

       Export: usePrefersReducedMotion

    2. Add memoization to src/components/Perlin.tsx:

       This is a HIGH PRIORITY performance optimization per 05-RESEARCH.md REQ-PERF-001.

       Add a Map-based cache to the Perlin class for perlin2 calculations:

       ```typescript
       // Add at top of Perlin class, after field declarations
       private noiseCache = new Map<string, number>();
       private readonly CACHE_SIZE_LIMIT = 1000;

       // Add new method for cached perlin2
       cachedPerlin2(x: number, y: number): number {
         // Round to 2 decimal places for cache key (reduces key space, increases hit rate)
         const key = `${x.toFixed(2)},${y.toFixed(2)}`;

         const cached = this.noiseCache.get(key);
         if (cached !== undefined) {
           return cached;
         }

         const value = this.perlin2(x, y);
         this.noiseCache.set(key, value);

         // Limit cache size to prevent memory bloat
         if (this.noiseCache.size > this.CACHE_SIZE_LIMIT) {
           // Delete oldest entry (first key in iteration order)
           const firstKey = this.noiseCache.keys().next().value;
           if (firstKey) this.noiseCache.delete(firstKey);
         }

         return value;
       }

       // Add method to clear cache (useful when seed changes or for testing)
       clearNoiseCache(): void {
         this.noiseCache.clear();
       }
       ```

       IMPORTANT: Keep the original perlin2() method unchanged for backward compatibility.
       The new cachedPerlin2() method wraps it with memoization.
  </action>
  <verify>
    - File exists: src/hooks/usePrefersReducedMotion.ts
    - File modified: src/components/Perlin.tsx contains noiseCache
    - TypeScript compiles without errors: `npm run build`
    - Perlin class exports both perlin2 and cachedPerlin2 methods
    - Hook exports correctly: `import { usePrefersReducedMotion } from './hooks/usePrefersReducedMotion'`
  </verify>
  <done>
    - usePrefersReducedMotion hook created with SSR-safe initialization
    - Hook responds to matchMedia changes in real-time
    - Perlin.tsx has cachedPerlin2() method with Map-based memoization
    - Cache limited to 1000 entries to prevent memory bloat
    - Ready for integration with animation components
  </done>
</task>

<task type="auto">
  <name>Task 3: Initialize monitoring in main.tsx</name>
  <files>
    - src/main.tsx
  </files>
  <action>
    Update src/main.tsx to initialize performance monitoring:

    1. Import initWebVitals from './performance/vitals'
    2. Import monitorLongAnimationFrames from './performance/loafMonitor'
    3. Call both functions BEFORE createRoot() to capture all metrics:
       ```typescript
       import { initWebVitals } from './performance/vitals';
       import { monitorLongAnimationFrames } from './performance/loafMonitor';

       // Initialize performance monitoring
       initWebVitals();
       monitorLongAnimationFrames();

       createRoot(document.getElementById("root")!).render(...)
       ```

    This ensures metrics are captured from first paint.
  </action>
  <verify>
    - `npm run dev` starts without errors
    - Open browser DevTools console, see Web Vitals logs after page interaction
    - Console shows "[Web Vitals] LCP:", "[Web Vitals] INP:", etc.
    - `npm run build` succeeds
  </verify>
  <done>
    - Performance monitoring initialized on app startup
    - Web Vitals logged to console in development
    - Long Animation Frames monitored for INP debugging
  </done>
</task>

</tasks>

<verification>
Run verification sequence:

1. `npm run build` - TypeScript and build must succeed
2. `npm run dev` - Dev server starts
3. In browser console, after interacting with page:
   - See "[Web Vitals] LCP: ..." log
   - See "[Web Vitals] CLS: ..." log
   - After clicking/interacting: "[Web Vitals] INP: ..." log
4. Check network tab - web-vitals library loaded (~2KB)
5. Verify Perlin.tsx has cachedPerlin2 method by checking file contents
</verification>

<success_criteria>
- web-vitals v5.x installed in package.json
- Performance monitoring files created in src/performance/
- usePrefersReducedMotion hook created and typed correctly
- Perlin.tsx has cachedPerlin2() with memoization cache
- main.tsx calls monitoring functions before render
- Dev console shows Web Vitals metrics after page load and interaction
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-animation/05-01-SUMMARY.md`
</output>
