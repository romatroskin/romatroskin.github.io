---
phase: 06-testing-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/setupTests.ts
  - src/components/ErrorBoundary/ErrorBoundary.tsx
  - src/components/ErrorBoundary/WaveAnimationFallback.tsx
  - src/components/ErrorBoundary/AppFallback.tsx
  - src/components/ErrorBoundary/ErrorBoundary.module.css
  - src/components/ErrorBoundary/ErrorBoundary.test.tsx
  - src/utils/storage.ts
  - src/utils/storage.test.ts
  - src/hooks/useTheme.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Error in wave animation shows fallback gradient instead of white screen"
    - "Error in main content shows retry button instead of crashing"
    - "localStorage unavailability falls back to in-memory storage without breaking theme"
    - "React Spring animations are skipped in tests (no timeouts)"
  artifacts:
    - path: "src/components/ErrorBoundary/ErrorBoundary.tsx"
      provides: "Reusable error boundary wrapper using react-error-boundary"
      exports: ["ErrorBoundary"]
    - path: "src/components/ErrorBoundary/WaveAnimationFallback.tsx"
      provides: "Wave-specific gradient fallback UI"
      exports: ["WaveAnimationFallback"]
    - path: "src/components/ErrorBoundary/AppFallback.tsx"
      provides: "App-level fallback with retry button"
      exports: ["AppFallback"]
    - path: "src/utils/storage.ts"
      provides: "localStorage wrapper with in-memory fallback"
      exports: ["storage"]
  key_links:
    - from: "src/App.tsx"
      to: "src/components/ErrorBoundary"
      via: "ErrorBoundary wrapping wave section and app content"
      pattern: "<ErrorBoundary"
    - from: "src/hooks/useTheme.tsx"
      to: "src/utils/storage.ts"
      via: "storage.getItem/setItem instead of localStorage direct"
      pattern: "storage\\.(get|set)Item"
---

<objective>
Implement layered error boundaries and graceful fallbacks for production resilience.

Purpose: Prevent white screen of death when wave animations or other components fail. Ensure theme persistence works even when localStorage is unavailable. Enable reliable test execution with react-spring.

Output: Error boundary components, storage utility with fallback, and integrated error handling in App.tsx.
</objective>

<execution_context>
@/Users/romatroskin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/romatroskin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-testing-error-handling/06-RESEARCH.md

@src/App.tsx
@src/hooks/useTheme.tsx
@src/setupTests.ts
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure test setup</name>
  <files>package.json, src/setupTests.ts</files>
  <action>
1. Install react-error-boundary:
   ```bash
   npm install react-error-boundary
   ```

2. Update src/setupTests.ts to skip React Spring animations:
   - Import `{ Globals }` from '@react-spring/web'
   - Call `Globals.assign({ skipAnimations: true })` at the top level
   - Keep existing jest-dom matchers and ResizeObserver mock
  </action>
  <verify>
   - Run `npm test -- --run` to verify tests pass with new setup
   - Check package.json has react-error-boundary
  </verify>
  <done>
   - react-error-boundary is installed
   - React Spring animations are skipped in test environment
   - Existing tests continue to pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error boundary components and storage utility</name>
  <files>
    src/components/ErrorBoundary/ErrorBoundary.tsx
    src/components/ErrorBoundary/WaveAnimationFallback.tsx
    src/components/ErrorBoundary/AppFallback.tsx
    src/components/ErrorBoundary/ErrorBoundary.module.css
    src/utils/storage.ts
  </files>
  <action>
1. Create src/utils/storage.ts:
   - Implement `isLocalStorageAvailable()` function with try-catch test
   - Create in-memory fallback using Map<string, string>
   - Export `storage` object with `getItem`, `setItem`, `removeItem` methods
   - Each method tries localStorage first, falls back to memory on failure
   - Type-safe keys: use union type `'theme' | 'reducedMotion'`

2. Create src/components/ErrorBoundary/ErrorBoundary.module.css:
   - `.fallback` - basic error fallback container
   - `.waveFallback` - full-screen gradient background matching wave aesthetic
   - `.appFallback` - centered card with padding for retry UI
   - `.retryButton` - styled button for retry action
   - Support both light and dark themes via CSS variables

3. Create src/components/ErrorBoundary/WaveAnimationFallback.tsx:
   - Accept FallbackProps from react-error-boundary
   - Render gradient background matching wave colors:
     Light theme: linear-gradient(180deg, hsl(235, 40%, 85%) 0%, hsl(210, 40%, 75%) 100%)
     Dark theme: linear-gradient(180deg, hsl(235, 60%, 25%) 0%, hsl(210, 60%, 20%) 100%)
   - Use `aria-label="Background animation unavailable"` for accessibility
   - NO retry button (silent fallback - waves are non-essential)

4. Create src/components/ErrorBoundary/AppFallback.tsx:
   - Accept FallbackProps (error, resetErrorBoundary)
   - Show generic "Something went wrong" message (no technical details in production)
   - In development (import.meta.env.DEV): show error.message in <pre> tag
   - Include "Try again" button calling resetErrorBoundary
   - Use role="alert" for screen reader announcement

5. Create src/components/ErrorBoundary/ErrorBoundary.tsx:
   - Re-export ErrorBoundary from react-error-boundary for consistent imports
   - Export WaveAnimationFallback and AppFallback from same location
   - Add error logging callback that logs to console in dev mode only
  </action>
  <verify>
   - Files exist at specified paths
   - TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
   - storage.ts handles localStorage failures gracefully
   - Three error boundary components ready for use
   - CSS supports light/dark themes
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate error boundaries and storage into App</name>
  <files>src/App.tsx, src/hooks/useTheme.tsx, src/components/ErrorBoundary/ErrorBoundary.test.tsx, src/utils/storage.test.ts</files>
  <action>
1. Update src/hooks/useTheme.tsx:
   - Import storage from '../utils/storage'
   - Replace direct localStorage.getItem calls with storage.getItem
   - Replace direct localStorage.setItem calls with storage.setItem
   - Keep same behavior, just use abstraction layer

2. Update src/App.tsx to wrap with error boundaries:
   - Import ErrorBoundary, WaveAnimationFallback, AppFallback
   - Wrap the entire return with ErrorBoundary using AppFallback
   - Wrap the wave animation div (containing waveConfigs.map) with ErrorBoundary using WaveAnimationFallback
   - Add resetKeys={[theme, qualityLevel]} to wave error boundary (reset on state changes)

   Structure should be:
   ```tsx
   <ErrorBoundary FallbackComponent={AppFallback}>
     <SkipLink />
     <Header />
     <div style={{...}}>
       <ErrorBoundary FallbackComponent={WaveAnimationFallback} resetKeys={[theme, qualityLevel]}>
         {/* Wave animation div */}
       </ErrorBoundary>
       {/* Parallax content */}
     </div>
   </ErrorBoundary>
   ```

3. Create src/components/ErrorBoundary/ErrorBoundary.test.tsx:
   - Test that error boundary catches errors and shows fallback
   - Test that children render normally when no error
   - Test retry functionality with resetErrorBoundary
   - Mock console.error in tests to suppress expected error output

4. Create src/utils/storage.test.ts:
   - Test getItem returns value from localStorage
   - Test setItem writes to localStorage
   - Test fallback to memory when localStorage throws
   - Mock localStorage to simulate unavailability
  </action>
  <verify>
   - Run `npm test -- --run` - all tests pass
   - Run `npm run build` - builds successfully
   - Run `npm run dev` and verify waves render normally
  </verify>
  <done>
   - Waves are wrapped in error boundary with gradient fallback
   - App has catch-all error boundary with retry button
   - useTheme uses storage abstraction
   - Tests verify error handling behavior
  </done>
</task>

</tasks>

<verification>
1. Error boundary test: In browser console, force an error in wave component and verify gradient fallback appears (not white screen)
2. Test suite: `npm test -- --run` passes all tests including new error boundary tests
3. Build: `npm run build` succeeds without errors
4. Visual: `npm run dev` shows waves animating normally (no regressions)
</verification>

<success_criteria>
- Error in wave animation shows gradient fallback instead of crashing
- App-level errors show retry button instead of white screen
- Storage utility gracefully handles localStorage unavailability
- All tests pass with React Spring animations properly skipped
- No visual regressions in normal operation
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-error-handling/06-01-SUMMARY.md`
</output>
